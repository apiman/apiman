= apiman - Installation Guide
:homepage: http://apiman.io/
:doctype: book

== Installation
This guide provides detailed information about how to install and configure apiman.

=== Installing in WildFly 8
The apiman project primarily targets WildFly 8 as a runtime environment.  In order to install
apiman you will need to download both WildFly 8 and the apiman overlay distribution.  Once
both are downloaded, it's a simple matter of unpacking both into the same location.

==== Download
First you will need to download both WildFly 8 and apiman:

* http://download.jboss.org/wildfly/8.2.0.Final/wildfly-8.2.0.Final.zip[Download WildFly 8]
* http://downloads.jboss.org/overlord/apiman/1.1.4.Final/apiman-distro-wildfly8-1.1.4.Final-overlay.zip[Download apiman 1.1.4.Final]

....
curl http://download.jboss.org/wildfly/8.2.0.Final/wildfly-8.2.0.Final.zip -o wildfly-8.2.0.Final.zip
curl http://downloads.jboss.org/overlord/apiman/1.1.4.Final/apiman-distro-wildfly8-1.1.4.Final-overlay.zip -o apiman-distro-wildfly8-1.1.4.Final-overlay.zip
....

==== Unpack
Once both files have been downloaded, simply unpack both in the same location.

....
unzip wildfly-8.2.0.Final.zip
unzip -o apiman-distro-wildfly8-1.1.4.Final-overlay.zip -d wildfly-8.2.0.Final
....

==== Run WildFly 8
The apiman overlay contains everything needed to run apiman, including:

* apiman binaries (several WAR files)
* apiman-specific WildFly 8 configuration (*standalone-apiman.xml*)
* apiman rdbms datasource (h2)
* pre-configured *admin* user with password *admin123!*
* pre-configured h2 database for the API Manager (populated with default values)

For this reason, there is no additional configuration required to run apiman.  Simply start up
WildFly using the apiman configuration file:

....
cd wildfly-8.2.0.Final
./bin/standalone.sh -c standalone-apiman.xml
....


=== Installing using Docker
Another option when installing apiman is to use our docker image.  You're probably pretty
familiar with docker if you're going that route, but here is an example of how to start up
the apiman docker image:

....
docker pull apiman/on-wildfly8
docker run -it -p 8080:8080 apiman/on-wildfly8
....

[NOTE]
====
You can find apiman on https://registry.hub.docker.com/repos/apiman/[docker hub].
====

== Logging In
Once apiman is running, you should be able to log in to the API Manager by pointing your
browser at the following URL:

....
http://localhost:8080/apimanui/
....

You may log in with credentials *admin/admin123!*.
[NOTE]
====
We strongly advise that you immediately change the Keycloak admin user password, as well
as the "admin" user found in the "apiman" realm!!  ( you can do that by navigating to
http://localhost:8080/auth/admin/ )
====


== General Configuration
Of course apiman is made up of a number of different components, many of which can be configured
to use various implementations and/or providers.  When downloading and installing apiman, the
default distribution includes reasonable default values for all options.  This section details
these options and explains the default values.

=== Configuration Properties
All of the apiman WARs share a common configuration file called *apiman.properties*, which can
be found in *standalone/configuration*.  This file therefore contains configuration settings
for all three applications (API Manager, API Manager UI, API Gateway).

Here is a breakdown of the properties found in this configuration file:

* *apiman.plugins.repositories*
+
Typical Value:: http://repository.jboss.org/nexus/content/groups/public/
+
Description:: A comma separated list of maven repositories from which to (try to) download apiman plugins.

* *apiman-manager-ui.api.endpoint*
+
Typical Value:: <empty>
+
Description:: The public endpoint of the API Manager's REST API.  This is used by the API Manager UI to communicate with the back end.  If ommitted, the UI will assume the back-end is located on the same server as the UI.

* *apiman-manager-ui.api.authentication.type*
+
Typical Value:: bearerToken
+
Description:: The type of authentication used by the API Manager UI when communicating with the API Manager.

* *apiman-manager-ui.api.authentication.token.generator*
+
Typical Value:: io.apiman.manager.ui.server.wildfly8.KeyCloakBearerTokenGenerator
+
Description:: The class used by the UI to generate authentication tokens (only used for certain types of authentication).

* *apiman-gateway.registry*
+
Typical Value:: io.apiman.gateway.engine.ispn.InfinispanRegistry
+
Description:: The implementation of the service/application registry used by the API Gateway.  By default a persistent Infinispan cache is used.

* *apiman-gateway.connector-factory*
+
Typical Value:: io.apiman.gateway.platforms.servlet.connectors.HttpConnectorFactory
+
Description:: The implementation of a connector factory for API endpoints of type "http".  This factory is used by the Gateway when proxying a request to a back-end endpoint.

* *apiman-gateway.policy-factory*
+
Typical Value:: io.apiman.gateway.engine.policy.PolicyFactoryImpl
+
Description:: The class that the API Gateway will use creating policies.

* *apiman-gateway.components.ISharedStateComponent*
+
Typical Value:: io.apiman.gateway.engine.ispn.InfinispanSharedStateComponent
+
Description:: The implementation of the shared-state component - a component that can store arbitrary state across request invocations.

* *apiman-gateway.components.IRateLimiterComponent*
+
Typical Value:: io.apiman.gateway.engine.ispn.InfinispanRateLimiterComponent
+
Description:: The implementation of the rate limiter component, which is used by the rate limiting policy.

* *apiman-gateway.components.IPolicyFailureFactoryComponent*
+
Typical Value:: io.apiman.gateway.platforms.servlet.PolicyFailureFactoryComponent
+
Description:: The implementation class to use for the factory that creates policy failures.


=== API Manager Database
The API Manager, by default, is a typical CDI application and uses JPA/Hibernate to persist its data.  The
JPA layer requires a data source to connect to a supported database.  When running in WildFly this
datasource is made available by deploying the following file:

....
standalone/deployments/apiman-ds.xml
....

Out of the box this data source is usually a simple H2 configuration, but you can (of course) change
it to support whatever database you desire.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<datasources>
  <datasource jndi-name="jdbc/ApiManDT" pool-name="apiman-manager-api" enabled="true"
    use-java-context="true">
    <connection-url>jdbc:h2:${jboss.server.data.dir}${/}h2${/}apiman-manager-api;MVCC=true</connection-url>
    <driver>h2</driver>
    <security>
      <user-name>sa</user-name>
    </security>
  </datasource>
</datasources>
```

The project comes with DDLs for MySQL and PostgreSQL, to hopefully make it easy to switch away from H2.  Note
that switching databases also requires a change to the standalone-apiman.xml file.  The following
should be changed to appropriate values for your database:

```xml
  <system-properties>
    <property name="apiman.hibernate.dialect" value="org.hibernate.dialect.MySQL5Dialect" />
    <property name="apiman.hibernate.hbm2ddl.auto" value="validate" />
  </system-properties>
```

You can, of course, set the hbm2ddl property to "update" so that hibernate automatically creates the
database structure when it starts up.  Alternatively, the MySQL and PostgreSQL DDLs can be found in
*apiman/ddls/*.

=== API Gateway Registry
The API Gateway includes a registry that stores the published service and application information.
This registry is updated whenever a user publishes a service (or registers an application) from
within the API Manager UI.  The registry contains just the configuration information necessary for
the API Gateway to properly apply the appropriate policies to all inbound requests.

Out of the box, the API Gateway is configured to use a persistent Infinispan cache to store the
published/registered data.  The configuration of the Infinispan cache can be found in
*standalone-apiman.xml* and is detailed here:

```xml
<subsystem xmlns="urn:jboss:domain:infinispan:2.0">
  <cache-container name="apiman-gateway" default-cache="registry" start="EAGER">
    <local-cache name="registry" batching="true">
      <file-store passivation="false" purge="false" />
    </local-cache>
  </cache-container>
</subsystem>
```

This cache can be configured however you choose, but in all cases should be made persistent.


=== API Gateway Rate Limiter
Part of the running apiman system is a "Rate Limiter" component.  This component is used by
apiman policies to enforce rate limits and uses an Infinispan cache to store data.  The
configuration of the Infinispan cache can be found in *standalone-apiman.xml* and is
detailed here:

```xml
<subsystem xmlns="urn:jboss:domain:infinispan:2.0">
  <cache-container name="apiman-gateway" default-cache="registry" start="EAGER">
    <local-cache name="rate-limiter" batching="true">
      <file-store passivation="false" purge="false"/>
    </local-cache>
  </cache-container>
</subsystem>
```


=== API Gateway Shared State
Part of the running apiman system is a "Shared State" component.  This component is used by
apiman policies to share interesting state information across multiple requests.  The
shared state component uses another Infinispan cache to store data.  The
configuration of the Infinispan cache can be found in *standalone-apiman.xml* and is
detailed here:

```xml
<subsystem xmlns="urn:jboss:domain:infinispan:2.0">
  <cache-container name="apiman-gateway" default-cache="registry" start="EAGER">
    <local-cache name="shared-state" batching="true">
      <file-store passivation="false" purge="false" />
    </local-cache>
  </cache-container>
</subsystem>
```

=== Gateway API Authentication
The Gateway's REST API is what the API Manager invokes when publishing services and applications
to the Gateway.  This REST API should be protected, often using BASIC authentication.  By default,
the Gateway REST API requires BASIC authentication credentials, as well as a role of *apipublisher*.
In other words, the Gateway REST API can only be invoked by a valid user, and that user must have
the *apipublisher* role.


== HowTos
This section contains specific instructions for how to configure apiman for specific scenarios.
For example, it is possible to use Elasticsearch instead of Infinispan for certain API Gateway
components.  This section details how to make these sorts of changes.

=== How To:  Use Elasticsearch instead of an RDBMS in the API Manager
The apiman quickstart is configured (by default) to use JPA as the persistence technology for
storing all of its data.  But this isn't the only persistence technology supported.  Another
option is to use Elasticsearch instead.  This section details how to set up apiman for this
use-case.

==== High Level Overview
1. Download and install https://www.elastic.co/downloads/elasticsearch[Elasticsearch]
2. Make changes to "apiman.properties" to switch from JPA to Elasticsearch
3. (Re)start apiman!
4. Perform standard admin configuration of apiman (the database will of course be empty!)

==== Download and install Elasticsearch
This part is pretty easy - download the Elasticsearch software and get it running.  A very good
resource for this can be found here:

http://www.elastic.co/guide/en/elasticsearch/guide/master/getting-started.html

==== Make changes to "apiman.properties"
Once Elasticsearch is running smoothly, you must make some changes to the *apiman.properties*
file in order to tell apiman to use ES instead of a database.  You should modify the
apiman.properties file to have the following properties set:

----
apiman.es.host=
apiman.es.port=
apiman.es.cluster-name=
apiman-manager.storage.type=es
apiman-manager.storage.es.host=${apiman.es.host}
apiman-manager.storage.es.port=${apiman.es.port}
apiman-manager.storage.es.cluster-name=${apiman.es.cluster-name}
apiman-manager.storage.es.initialize=true
----

Make sure you enter appropriate values for the apiman.es.host, apiman.es.port, and apiman.es.cluster-name
properties.  These values should reflect the settings of your Elasticsearch installation.

==== (Re)start apiman
If apiman was running, you should stop it now.  Once everything is shutdown, and the changes
to apiman.properties have been made, go ahead and start apiman up again.  It will pick up the
new settings in apiman.properties and attempt to use Elasticsearch instead of the database!

.Perform standard admin configuration
Note that the apiman quickstart comes pre-configured with a number of settings, including:

* Installed policy definitions
* Default configured roles (Organization Owner, Service Developer, Appliation Developer)
* A default configured Gateway

This built-in configuration will be lost when you switch from JPA to Elasticsearch.  You will
need to use the apiman admin UI to reconfigure these settings.  Refer to the "System Administration"
section of the User Guide for more information on this.


=== How To:  Use Elasticsearch instead of Infinispan in the API Gateway
The apiman quickstart ships by default with an Infinispan based provider for various
runtime components in the API Gateway.  This includes, for example, the Rate Limiter
component which is used to track limits across a potential cluster of API Gateway
nodes (ensuring that the limits are consistent and effective despite traffic being
split across API Gateway nodes in a cluster).

The following components currently use Infinispan and can be switched to Elasticsearch:

* API Gateway Registry (used to store the gateway configuration)
* Rate Limiter Component (used to track limits)
* Shared State Component (used by policies to share state across multiple requests)

Each of these components can be configured separately.  So you can use Infinispan for
the last two but Elasticsearch for the first one, for example.

==== High Level Overview
1. Download and install https://www.elastic.co/downloads/elasticsearch[Elasticsearch]
2. Make changes to "apiman.properties" to switch from JPA to Elasticsearch
3. (Re)start apiman!

==== Download and install Elasticsearch
This part is pretty easy - download the Elasticsearch software and get it running.  A very good
resource for this can be found here:

http://www.elastic.co/guide/en/elasticsearch/guide/master/getting-started.html

==== Make changes to "apiman.properties"
Once Elasticsearch is running smoothly, you must make some changes to the *apiman.properties*
file in order to tell apiman to use ES for the runtime components.

First, it's often useful to set a common set of properties for the Elasticsearch
host, port, and cluster-name.  This way these properties can be re-used for the
configuration of each of the components.

----
apiman-gateway.es.host=
apiman-gateway.es.port=
apiman-gateway.es.cluster-name=
----

Make sure you enter appropriate values for the apiman.es.host, apiman.es.port, and apiman.es.cluster-name
properties.  These values should reflect the settings of your Elasticsearch installation.

Next, each of the components can be configured by changing/adding the following properties
in *apiman.properties*.  Make sure any of the properties below which already have values
are removed before the ones below are copied in.

===== API Gateway Registry
Here is how you switch the API Gateway Registry over to Elasticsearch.
----
apiman-gateway.registry=io.apiman.gateway.engine.es.ESRegistry
apiman-gateway.registry.client.type=jest
apiman-gateway.registry.client.cluster-name=${apiman-gateway.es.cluster-name}
apiman-gateway.registry.client.host=${apiman-gateway.es.host}
apiman-gateway.registry.client.port=${apiman-gateway.es.port}
----

===== Rate Limiter Component
Here is how you switch the Rate Limiter Component over to Elasticsearch.
----
apiman-gateway.components.IRateLimiterComponent=io.apiman.gateway.engine.es.ESRateLimiterComponent
apiman-gateway.components.IRateLimiterComponent.client.type=jest
apiman-gateway.components.IRateLimiterComponent.client.cluster-name=${apiman-gateway.es.cluster-name}
apiman-gateway.components.IRateLimiterComponent.client.host=${apiman-gateway.es.host}
apiman-gateway.components.IRateLimiterComponent.client.port=${apiman-gateway.es.port}
----

===== Shared State Component
Here is how you switch the Shared State Component over to Elasticsearch.
----
apiman-gateway.components.ISharedStateComponent=io.apiman.gateway.engine.es.ESSharedStateComponent
apiman-gateway.components.ISharedStateComponent.client.type=jest
apiman-gateway.components.ISharedStateComponent.client.cluster-name=${apiman-gateway.es.cluster-name}
apiman-gateway.components.ISharedStateComponent.client.host=${apiman-gateway.es.host}
apiman-gateway.components.ISharedStateComponent.client.port=${apiman-gateway.es.port}
----

==== (Re)start apiman
If apiman was running, you should stop it now.  Once everything is shutdown, and the changes
to apiman.properties have been made, go ahead and start apiman up again.  It will pick up the
new settings in apiman.properties and attempt to use Elasticsearch instead of Infinispan.


=== How To:  Enable MTLS (Mutual SSL) Support for Endpoint Security
If you wish to use mutual SSL to ensure endpoint security between the apiman API Gateway and
your back-end service(s), you must update some settings in the apiman.properties file.

==== High Level Overview
1. Create Trust and Key Stores
2. Make changes to "apiman.properties" to switch from JPA to Elasticsearch
3. (Re)start apiman!
4. Configure one or more Service to use MTLS

==== Create Trust and Key Stores
Please refer to https://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html[official JDK documentation]
to learn how to create and managed your SSL Trust and Key stores. Minimally a Keystore
is required in order to successfully utilise MTLS, and in many cases also a Truststore.

A *keystore* contains a given node's private key material, and must be kept safe.
Each node should have a unique key entry. For instance, a gateway should have its
own keystore, and each service likewise. In a production system, these keys should
be issued by a trusted certificate authority.

A *truststore* typically contains a set of certificate authorities which are trusted issuers.
Therefore, any certificate signed by the trusted CA would be trusted by the gateway. If
no truststore is explicitly provided to apiman the
https://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html#cacerts[default trusted certificates]
provided by the JVM will be used. A typical use-case would be that an organization's
internal signing authority is marked as trusted within in the truststore,
and as the authority has been used to sign the certificate material in the keystores,
they will mutually trust each other by virtue of the issuer.

It is also possible to directly insert the *public/self-signed certificate* corresponding
to a given private key pair into a truststore, which works well at small scales and for development, but will
quickly cause the accumulation of a huge number of certificates in larger systems as
it requires a 1:1 mapping of certificates and private keys (rather than 1:N by using a trusted authority).

Your back-end services must be SSL enabled and *require authenticated client SSL connections*.
This means you must have server SSL certificates generated (and appropriate certificates and/or
CAs stored in your Trust Store).

==== Example Scenarios

There are many potential configuration permutations, but we'll outline a few simple ones here to
get you started.

===== Development Setup

In our hypothetical development setup, let's imagine we have two services and a single gateway.

[cols="1,1,2", options="header"]
.Simple Development MTLS Setup
|===
|Component
|Key Alias
|Truststore's Trusted Certificates

|Apiman Gateway
|gateway
|service_a.cer, service_b.cer

|Service A
|service_a
|gateway.cer

|Service B
|service_b
|gateway.cer

|===

.Walkthrough
* Generate a keystore and export a certificate for each component:

    ** Gateway:

      keytool -genkey -keyalg RSA -keystore gateway_ks.jks -alias gateway
      keytool -export -alias gateway -file gateway.cer -keystore gateway_ks.jks

    ** Service A:

      keytool -genkey -keyalg RSA -keystore service_a_ks.jks -alias service_a
      keytool -export -alias service_a -file service_a.cer -keystore service_a_ks.jks

    ** Service B:

      keytool -genkey -keyalg RSA -keystore service_b_ks.jks -alias service_b
      keytool -export -alias service_b -file service_b.cer -keystore service_b_ks.jks

* Import certificates into appropriate trust stores:

  ** Gateway:

    keytool -import -file service_a.cer -alias service_a -keystore gateway_ts.jks
    keytool -import -file service_b.cer -alias service_b -keystore gateway_ts.jks

  ** Service A:

    keytool -import -file gateway.cer -alias gateway -keystore service_a_ts.jks

  ** Service B:

    keytool -import -file gateway.cer -alias gateway -keystore service_b_ts.jks

Now simply set the appropriate paths to the keystore and truststore in
`apiman.properties` for the gateway, and set up your services with their respective
truststores and keystores (the specifics of how to do this will depend on your
service's implementation).

We will also set the following in `apiman.properties` to make our development
easier:

  apiman-gateway.connector-factory.tls.allowAnyHost=true

When you add your MTLS protected services into apiman, you should set the
`API Security` field to `MTLS/Two-Way-SSL`.

===== MTLS via Custom Certificate Authority

The previous approach works for development, but doesn't scale well, is harder to manage
and doesn't gracefully handle revocations, expiry, expansion, etc. Instead, let's
summarise a scenario where an organisation has an internal CA which they use to
sign services' certificates. The process for generating a CA and signing
certificates is out of scope for this guide, but is trivial to accomplish using
OpenSSL, LibreSSL, or similar.

Let's imagine we have a CA called `apimanCA`, and have *signed* the certificates
for each node.

[cols="3", options="header"]
.CA-based MTLS Setup
|===
|Component
|Signed Key Alias
|Truststore Contents

|Apiman Gateway
|gateway (signed by apimanCA)
|apimanCA.cer

|Service A
|service_a (signed by apimanCA)
|apimanCA.cer

|Service N
|service_n (signed by apimanCA)
|apimanCA.cer

|===

Despite the initial administrative work setting up the CA and signing the
certificates, this process is drastically less effort to maintain in large
deployments. Only the trusted CA needs to be in the truststore, and any
certificates signed by it are trusted by virtue of this.

==== Make changes to "apiman.properties"
Once you have your Trust Store and Key Store properly configured, you must
configure your apiman.properties file.  Here is a summary of the properties:

Omit any properties which are not relevant to you, with the exception of
`trustStore`, which is mandatory for MTLS.

----
# ---------------------------------------------------------------------
# SSL/TLS settings for the gateway connector(s).
# ---------------------------------------------------------------------

# Trust store contains certificate(s) trusted by gateway.
apiman-gateway.connector-factory.tls.trustStore=<PATH_TO_TRUST_STORE>
apiman-gateway.connector-factory.tls.trustStorePassword=<PASSWORD_IF_ANY>

# Key store contains gateway's keys (including private components: keep it safe).
apiman-gateway.connector-factory.tls.keyStore=<PATH_TO_KEY_STORE>
apiman-gateway.connector-factory.tls.keyStorePassword=<PASSWORD_IF_ANY> # Password on key store as a whole
apiman-gateway.connector-factory.tls.keyPassword=<PASSWORD_IF_ANY> # Password on specific key(s)
# By default all keys can be used (will try all). If alias list provided, will only attempt to use listed keys.
apiman-gateway.connector-factory.tls.keyAliases=<COMMA_SEPARATED_LIST>

# Allowed TLS/SSL protocols and ciphers suites as CSV. Availability will vary depending on your JVM impl.
# Uses JVM defaults depending if not explicitly provided.
# See: https://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html
apiman-gateway.connector-factory.tls.allowedProtocols=TLSv1.2,TLSv1.1
apiman-gateway.connector-factory.tls.allowedCiphers=TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA

# Whether certificate host checks should be bypassed. *Use with great care.*
apiman-gateway.connector-factory.tls.allowAnyHost=false

# Whether self-signed certificates should be automatically trusted. *Use with great care.*
apiman-gateway.connector-factory.tls.allowSelfSigned=false
----

CAUTION: The settings chosen here have significant security implications. Best practice
guides are https://www.owasp.org/[available at OWASP].

==== (Re)start apiman
If apiman was running, you should stop it now.  Once everything is shutdown, and the changes
to apiman.properties have been made, go ahead and start apiman up again.

==== Configure one or more Service to use MTLS
Now that the apiman MTLS feature has been configured, use the Manager UI to enable MTLS in
one or more Service.  This can be done on the "Implementation" tab when you are configuring
the details of your back-end endpoint (URL, type, and endpoint security).

:numbered!:
